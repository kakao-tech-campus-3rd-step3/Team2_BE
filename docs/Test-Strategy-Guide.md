# Pullit 프로젝트 테스트 전략 가이드

우리 프로젝트는 코드의 안정성과 유지보수성을 높이기 위해, 목적에 따라 명확하게 구분된 4가지 테스트 유형을 사용합니다. 새로운 테스트를 작성하기 전에, 이 가이드를 참고하여 가장 적절한 테스트 유형을 선택해주세요.

### 🎯 우리 팀의 테스트 접근 방식

> **"테스트 대상의 핵심 책임에 집중하고, 외부 의존성은 격리한다."**

우리 팀은 테스트의 복잡성을 낮추고 명확성을 높이기 위해, **'핵심 비즈니스 로직'** 을 프레임워크 의존성이 없는 순수한 자바 클래스(POJO)로 분리하는 설계를 지향합니다.

**적용 예시: `JwtAuthenticationFilter`**

1.  **기존 문제:** `JwtAuthenticationFilter`는 토큰 검증, claim 추출 등 중요한 로직과 `HttpServletRequest`를 처리하는 프레임워크 코드가 혼재되어 있어 단위 테스트가 어려웠습니다.
2.  **개선 방향:** 핵심 로직을 `JwtAuthenticator`라는 별도의 클래스로 분리했습니다.
3.  **달성 효과:**
    *   `JwtAuthenticator`는 스프링에 의존하지 않으므로, `@UnitTest`를 통해 명확하고 빠르게 테스트할 수 있습니다.
    *   `JwtAuthenticationFilter`는 단순히 `JwtAuthenticator`를 호출하는 책임만 가지므로, 그 자체에 대한 복잡한 테스트는 필요하지 않게 됩니다.

이처럼 **'무엇을 테스트할 것인가'** 를 명확히 정의하고, 테스트하기 어려운 부분과 반드시 테스트해야 하는 핵심 로직을 분리하는 것이 우리 팀의 테스트 전략입니다.

---

### 📊 4가지 테스트 유형 요약

| 테스트 유형 | 담당 계층 | 핵심 어노테이션 | 목적 및 특징 | 대표 예시 |
| :--- | :--- | :--- | :--- | :--- |
| **단위 테스트** | 도메인, 유틸리티 | `@UnitTest` | 특정 클래스(객체)의 기능(메서드)이 독립적으로 잘 동작하는지 검증합니다. (가장 빠름) | `JwtAuthenticatorTest.java` |
| **JPA 슬라이스** | Repository (DB) | `@JpaSliceTest` | `Repository`와 `Entity`의 DB 연동(매핑, 쿼리)을 인메모리 DB로 검증합니다. | (추가 예정) |
| **MVC 슬라이스** | Controller | `@MvcSliceTest` | `Controller`의 API 요청/응답 처리를 웹 계층에 한정하여 검증합니다. | `MemberControllerTest.java` |
| **통합 테스트** | Service | `@IntegrationTest` | 여러 계층이 함께 동작하는 전체적인 시나리오를 검증합니다. (가장 느리지만 확실함) | `SourceServiceIntegrationTest.java` |

### ⚠️ 서비스 테스트에 대한 추가 설명

**서비스(`Service`) 검증은 통합 테스트(`@IntegrationTest`)를 원칙으로 합니다.**

서비스의 핵심 책임은 여러 컴포넌트(Repository, 다른 서비스 등)와의 상호작용을 조율하고 트랜잭션을 관리하는 것입니다. 따라서 서비스는 개별 단위로 테스트하기보다는, 실제와 유사한 환경에서 관련된 모든 계층이 함께 동작하는 것을 확인하는 통합 테스트가 가장 적합합니다.

**만약 서비스 검증이 힘들다면, 설계 개선의 신호입니다.**

만약 통합 테스트로 서비스를 검증하기 어렵다고 느껴진다면, 이는 서비스 내부에 순수한 비즈니스 로직(도메인 로직)이 과도하게 포함되어 있기 때문일 수 있습니다.

*   **문제점:** 복잡한 계산, 조건 분기, 정책 결정 등의 도메인 로직이 서비스 메서드 안에 있으면, 이 로직만을 테스트하기 위해 매번 무거운 통합 테스트를 실행해야 합니다. 이는 테스트 작성의 어려움을 높이고 실행 시간을 길게 만듭니다.
*   **해결책:** DDD 원칙에 따라, 이러한 도메인 로직을 별도의 도메인 객체(Entity, Value Object 등)로 분리해야 합니다. 그렇게 하면, 분리된 도메인 객체는 가벼운 `@UnitTest`로 빠르고 철저하게 검증할 수 있고, 서비스는 다시 본연의 책임인 '흐름 제어'에만 집중하여 더 간단한 통합 테스트로 검증할 수 있게 됩니다.
